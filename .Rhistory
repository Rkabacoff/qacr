dfd  <- sfit$fstatistic[3]
r    <- sqrt(sfit$r.squared)
p    <- pf(Fvalue, dfn, dfd, lower.tail = FALSE)
# studentized residuals
data$stud.residuals <- rstudent(fit)
# rmse
rmse <- sqrt(mean(residuals(fit)^2))
# flag outliers
data$outlier <- ifelse(abs(data$stud.residuals) >= outlier,
"outlier", "non-outlier")
# create informational inset
inset <- paste0(
# equation
y,
" = ",
round(b0, 2),
" + ",
round(b1, 2),
" * ",
x,
# F test
", F(",
dfn,
", " ,
dfd,
") = ",
round(Fvalue, 2),
", p = ",
round(p, 3),
# rmse and r
", rmse = ",
round(rmse, 2),
", r = ",
round(r, 3)
)
# create plot
p <- ggplot(data=data,
aes(x=.data[[x]],
y=.data[[y]])) +
geom_point(alpha=alpha,
aes(color=.data[["outlier"]])) +
geom_smooth(method=method,
formula=y~x,
color=line_color) +
scale_color_manual(values=c(point_color, outlier_color)) +
labs(title = title,
subtitle = inset) +
theme_bw() +
theme(legend.position="none",
plot.subtitle = element_text(size=8,face="plain"),
plot.caption = element_text(size=8, face="plain"))
# outlier caption
if (any(abs(data$stud.residuals) > outlier)){
p <- p + labs(caption=paste("Note: studentized residuals >",
outlier, "are highlighted."))
}
# add margins
if(margin!="none"){
p <- ggExtra::ggMarginal(p, size=8, type=margin,
fill=margin_color)
}
# return graph
p
}
scatter(qacData::countries, Exports, Imports)
scatter(qacData::countries, Inflation.rate.consumer.prices, Unemployment.rate)
scatter(qacData::countries[countries$Inflation.rate.consumer.prices<300,], Inflation.rate.consumer.prices, Unemployment.rate)
scatter(qacData::countries[qacData::countries$Inflation.rate.consumer.prices<300,], Inflation.rate.consumer.prices, Unemployment.rate)
library(qacr)
library(qacr)
tab(mtcars, cyl)
library(qacr)
tab(mtcars, cyl)
tab(mtcars, cyl, plot=TRUE)
build_site()
library(pkgdown)
build_site()
#' # If no keyword arguments are provided, default values are used
#' dstats(mtcars, mpg, am, gear)
#'
#' # You can supply as many (or no) grouping variables as needed
#' dstats(mtcars, mpg)
#'
#' dstats(mtcars, mpg, am, gear, cyl, carb)
#'
#' @rdname dstats
#' @export
qstats <- function(data, x, statistics=c("n", "mean", "std"),
na.rm=TRUE, ...){
x <- enquo(x)
dots <- enquos(...)
if(!is.numeric(data %>% pull(!!x))){
stop("data$x is not numeric")
}
## stats
median <- function(xs){
ys <- sort(xs)
m <- length(xs)/2
if(length(xs) %% 2 == 0){
mean(c(ys[m], ys[m+1]))
} else {
ys[floor(m) + 1]
}
}
n <- function(xs){
length(xs)
}
## Auxiliary functions
my_sum <- function(data, col, cus_sum) {
col <- enquo(col)
cus_sum_name <- cus_sum
cus_sum <- rlang::as_function(cus_sum)
data %>%
summarise(!!cus_sum_name := cus_sum(!!col))
}
my_sums <- function(data, col, cus_sums) {
col <- enquo(col)
purrr::map_dfc(cus_sums, my_sum, data = data, col = !!col)
}
extract_list_unnamed_elems <- function(my_list){
unnamed_idxs <- (1:length(my_list))[names(my_list)  == ""]
my_list[unnamed_idxs]
}
stats <- if(is.null(dots$stats)) {
c("n", "mean", "sd")
} else {
eval(rlang::quo_get_expr(dots$stats))
}
na.rm <- if(is.null(dots$na.rm)) TRUE else rlang::quo_get_expr(dots$na.rm)
digits <- if(is.null(dots$digits)) 2 else rlang::quo_get_expr(dots$digits)
grouping_vars <- extract_list_unnamed_elems(dots)
data <- data %>% select(!!x, !!!grouping_vars)
if(na.rm){
data <- stats::na.omit(data)
}
data %>%
mutate_at(vars(!!!grouping_vars), as_factor) %>%
group_by(!!!grouping_vars) %>%
group_modify(~my_sums(.x, col = !!x, cus_sums = stats)) %>%
mutate_at(vars(-group_cols()), ~ round(as.double(.x), digits = digits)) %>%
ungroup() %>% as.data.frame()
}
qstats(cars74, cyl)
#' # If no keyword arguments are provided, default values are used
#' dstats(mtcars, mpg, am, gear)
#'
#' # You can supply as many (or no) grouping variables as needed
#' dstats(mtcars, mpg)
#'
#' dstats(mtcars, mpg, am, gear, cyl, carb)
#'
#' @rdname dstats
#' @export
qstats <- function(data, x, statistics=c("n", "mean", "std"),
na.rm=TRUE, ...){
library(dplyr)
x <- enquo(x)
dots <- enquos(...)
if(!is.numeric(data %>% pull(!!x))){
stop("data$x is not numeric")
}
## stats
median <- function(xs){
ys <- sort(xs)
m <- length(xs)/2
if(length(xs) %% 2 == 0){
mean(c(ys[m], ys[m+1]))
} else {
ys[floor(m) + 1]
}
}
n <- function(xs){
length(xs)
}
## Auxiliary functions
my_sum <- function(data, col, cus_sum) {
col <- enquo(col)
cus_sum_name <- cus_sum
cus_sum <- rlang::as_function(cus_sum)
data %>%
summarise(!!cus_sum_name := cus_sum(!!col))
}
my_sums <- function(data, col, cus_sums) {
col <- enquo(col)
purrr::map_dfc(cus_sums, my_sum, data = data, col = !!col)
}
extract_list_unnamed_elems <- function(my_list){
unnamed_idxs <- (1:length(my_list))[names(my_list)  == ""]
my_list[unnamed_idxs]
}
stats <- if(is.null(dots$stats)) {
c("n", "mean", "sd")
} else {
eval(rlang::quo_get_expr(dots$stats))
}
na.rm <- if(is.null(dots$na.rm)) TRUE else rlang::quo_get_expr(dots$na.rm)
digits <- if(is.null(dots$digits)) 2 else rlang::quo_get_expr(dots$digits)
grouping_vars <- extract_list_unnamed_elems(dots)
data <- data %>% select(!!x, !!!grouping_vars)
if(na.rm){
data <- stats::na.omit(data)
}
data %>%
mutate_at(vars(!!!grouping_vars), as_factor) %>%
group_by(!!!grouping_vars) %>%
group_modify(~my_sums(.x, col = !!x, cus_sums = stats)) %>%
mutate_at(vars(-group_cols()), ~ round(as.double(.x), digits = digits)) %>%
ungroup() %>% as.data.frame()
}
qstats(cars74, cyl)
#' # If no keyword arguments are provided, default values are used
#' dstats(mtcars, mpg, am, gear)
#'
#' # You can supply as many (or no) grouping variables as needed
#' dstats(mtcars, mpg)
#'
#' dstats(mtcars, mpg, am, gear, cyl, carb)
#'
#' @rdname dstats
#' @export
qstats <- function(data, x, statistics=c("n", "mean", "std"),
digits=2, na.rm=TRUE, ...){
library(dplyr)
x <- enquo(x)
dots <- enquos(...)
if(!is.numeric(data %>% pull(!!x))){
stop("data$x is not numeric")
}
## stats
n <- function(xs){
length(xs)
}
## Auxiliary functions
my_sum <- function(data, col, cus_sum) {
col <- enquo(col)
cus_sum_name <- cus_sum
cus_sum <- rlang::as_function(cus_sum)
data %>%
summarise(!!cus_sum_name := cus_sum(!!col))
}
my_sums <- function(data, col, cus_sums) {
col <- enquo(col)
purrr::map_dfc(cus_sums, my_sum, data = data, col = !!col)
}
extract_list_unnamed_elems <- function(my_list){
unnamed_idxs <- (1:length(my_list))[names(my_list)  == ""]
my_list[unnamed_idxs]
}
grouping_vars <- extract_list_unnamed_elems(dots)
data <- data %>% select(!!x, !!!grouping_vars)
if(na.rm){
data <- stats::na.omit(data)
}
data %>%
mutate_at(vars(!!!grouping_vars), as_factor) %>%
group_by(!!!grouping_vars) %>%
group_modify(~my_sums(.x, col = !!x, cus_sums = stats)) %>%
mutate_at(vars(-group_cols()), ~ round(as.double(.x), digits = digits)) %>%
ungroup() %>% as.data.frame()
}
qstats(cars74, mpg, cyl)
?mutate_at
?as.factor
#' # If no keyword arguments are provided, default values are used
#' dstats(mtcars, mpg, am, gear)
#'
#' # You can supply as many (or no) grouping variables as needed
#' dstats(mtcars, mpg)
#'
#' dstats(mtcars, mpg, am, gear, cyl, carb)
#'
#' @rdname dstats
#' @export
qstats <- function(data, x, statistics=c("n", "mean", "std"),
digits=2, na.rm=TRUE, ...){
library(dplyr)
x <- enquo(x)
dots <- enquos(...)
if(!is.numeric(data %>% pull(!!x))){
stop("data$x is not numeric")
}
## stats
n <- function(xs){
length(xs)
}
## Auxiliary functions
my_sum <- function(data, col, cus_sum) {
col <- enquo(col)
cus_sum_name <- cus_sum
cus_sum <- rlang::as_function(cus_sum)
data %>%
summarise(!!cus_sum_name := cus_sum(!!col))
}
my_sums <- function(data, col, cus_sums) {
col <- enquo(col)
purrr::map_dfc(cus_sums, my_sum, data = data, col = !!col)
}
extract_list_unnamed_elems <- function(my_list){
unnamed_idxs <- (1:length(my_list))[names(my_list)  == ""]
my_list[unnamed_idxs]
}
grouping_vars <- extract_list_unnamed_elems(dots)
data <- data %>% select(!!x, !!!grouping_vars)
if(na.rm){
data <- stats::na.omit(data)
}
data %>%
mutate_at(vars(!!!grouping_vars), as.factor) %>%
group_by(!!!grouping_vars) %>%
group_modify(~my_sums(.x, col = !!x, cus_sums = stats)) %>%
mutate_at(vars(-group_cols()), ~ round(as.double(.x), digits = digits)) %>%
ungroup() %>% as.data.frame()
}
qstats(cars74, mpg, cyl)
#' # If no keyword arguments are provided, default values are used
#' dstats(mtcars, mpg, am, gear)
#'
#' # You can supply as many (or no) grouping variables as needed
#' dstats(mtcars, mpg)
#'
#' dstats(mtcars, mpg, am, gear, cyl, carb)
#'
#' @rdname dstats
#' @export
qstats <- function(data, x, statistics=c("n", "mean", "std"),
digits=2, na.rm=TRUE, ...){
library(dplyr)
x <- enquo(x)
dots <- enquos(...)
if(!is.numeric(data %>% pull(!!x))){
stop("data$x is not numeric")
}
## stats
n <- function(xs){
length(xs)
}
## Auxiliary functions
my_sum <- function(data, col, cus_sum) {
col <- enquo(col)
cus_sum_name <- cus_sum
cus_sum <- rlang::as_function(cus_sum)
data %>%
summarise(!!cus_sum_name := cus_sum(!!col))
}
my_sums <- function(data, col, cus_sums) {
col <- enquo(col)
purrr::map_dfc(cus_sums, my_sum, data = data, col = !!col)
}
extract_list_unnamed_elems <- function(my_list){
unnamed_idxs <- (1:length(my_list))[names(my_list)  == ""]
my_list[unnamed_idxs]
}
grouping_vars <- extract_list_unnamed_elems(dots)
data <- data %>% select(!!x, !!!grouping_vars)
if(na.rm){
data <- stats::na.omit(data)
}
data %>%
mutate_at(vars(!!!grouping_vars), as.factor) %>%
group_by(!!!grouping_vars) %>%
group_modify(~my_sums(.x, col = !!x, cus_sums = statistics)) %>%
mutate_at(vars(-group_cols()), ~ round(as.double(.x), digits = digits)) %>%
ungroup() %>% as.data.frame()
}
qstats(cars74, mpg, cyl)
library(dplyr)
cars74 %>% group_by(cyl) %>%
summarize(mean=mean(mpg))
cars74 %>% group_by() %>%
summarize(mean=mean(mpg))
cars74 %>% group_by(cyl) %>%
summarize(mean=mean(mpg))
?group_modify
rm(qstats)
debug(dstats)
dstats(mtcars, mpg, cyl)
dstats(mtcars, mpg, cyl, am)
dots
rlang::quo_get_expr(dots$stats)
?quo_get_expr
library(qacr)
library(qacr)
library(qacr)
library(qacr)
library(qacr)
library(qacr)
library(qacr)
dstats(mtcars, mpg, cyl)
dstats(mtcars, mpg, statistics=c("n", "median", "max", cyl)
dstats(mtcars, mpg, stats=c("n", "median", "max"), cyl)
library(qacr)
dstats(mtcars, mpg, stats=c("n", "median", "max"), cyl)
dstats(mtcars, mpg, cyl, stats=c("n", "median", "max"))
dstats(mtcars, mpg, cyl, stats=c("n", "median", "max"), digits=4)
?dstats
library(qacr)
?dstats
library(qacr)
?dstats
library(qacr)
?dstats
library(qacr)
?dstats
?dstats
?dstats
library(qacr)
?dstats
library(qacr)
?dstats
?qstats
library(dplyr)
f <- function(x)c(mean(x), sd(x))
mtcars %>% f(mpg)
mtcars %>% select(mpg) %>% f
mtcars %>% select(mpg)
mtcars %>% select(mpg) %>% unlist %>% f
mtcars %>% group_by(cyl) %>% select(mpg) %>% unlist %>% f
mtcars %>% group_by(cyl)  %>% f(mpg)
library(qacr)
library(qacr)
?qstats
qstats(mtcars, mpg, cyl, stats=c("quantile"))
?quantile
?by
?lm
?Chisquare
?t.test
?match.arg
ibrary(pkgdown)
library(pkgdown)
build_site()
str(cars74)
data(cars74)
str(cars74)
build_site()
build_site()
?histograms
library(qacr)
?histograms
?contents
build_site()
methods("contents")
build_site()
build_site()
library(qacr)
build_site()
#' @return a ggplot graph
#' @details
#' The \code{histograms} function will only plot quantitative variables from
#' a data frame. Categorical variables are ignored.
#' @examples
#' histograms(cars74)
#' @rdname histograms
#' @import tidyr
#' @import ggplot2
#' @export
histograms <- function(data, fill="deepskyblue2", bins=30){
index <- sapply(data, is.numeric)
qdata <- data[index]
qdata_long <- tidyr::gather(qdata)
ggplot2::ggplot(data=qdata_long, aes(x=.data[["value"]])) +
ggplot2::geom_histogram(fill=fill, color="white", bins=bins) +
ggplot2::facet_wrap(~key, scale="free") +
ggplot2::theme_bw() +
labs(title="Histograms")
}
histograms(cars74)
library(ggplot2)
library(tidyr)
histograms(cars74)
#' @return a ggplot graph
#' @details
#' The \code{histograms} function will only plot quantitative variables from
#' a data frame. Categorical variables are ignored.
#' @examples
#' histograms(cars74)
#' @rdname histograms
#' @import tidyr
#' @import ggplot2
#' @export
histograms <- function(data, fill="deepskyblue2", bins=30){
index <- sapply(data, is.numeric)
qdata <- data[index]
qdata_long <- tidyr::gather(qdata)
ggplot2::ggplot(data=qdata_long, aes(x=.data[["value"]])) +
ggplot2::geom_histogram(fill=fill, color="white", bins=bins) +
ggplot2::facet_wrap(~key, scale="free") +
ggplot2::theme_minimal() +
labs(title="Histograms")
}
histograms(cars74)
#' @return a ggplot graph
#' @details
#' The \code{histograms} function will only plot quantitative variables from
#' a data frame. Categorical variables are ignored.
#' @examples
#' histograms(cars74)
#' @rdname histograms
#' @import tidyr
#' @import ggplot2
#' @export
histograms <- function(data, fill="deepskyblue2", bins=30){
index <- sapply(data, is.numeric)
qdata <- data[index]
qdata_long <- tidyr::gather(qdata)
ggplot2::ggplot(data=qdata_long, aes(x=.data[["value"]])) +
ggplot2::geom_histogram(fill=fill, color="black", bins=bins) +
ggplot2::facet_wrap(~key, scale="free") +
ggplot2::theme_bw() +
labs(title="Histograms")
}
histograms(cars74)
