}
}
}
return(data)
}
data(mtcars)
df <- Recoder(mtcars, "mpg", c("$ < 15 | $ > 30"), NA)
View(df)
df <- Recoder(df, "mpg", NA, 0)
View(df)
debug(Recoder)
df <- Recoder(df, "mpg", NA, 0)
changed
changed
is.na(x[k])
is.na(data[[i]])[k]
Recoder <- function(data, vars, from, to){
df <- as.character(substitute(data))
# special character representing the variable being coded when
# the 'from' vector contains conditions rather than values
pattern <- "\\$"
# recycle 'from' to match 'to' in length
if (length(from) > length(to)){
to <- rep_len(to, length(from))
message("Note: 'from' is longer than 'to'. Recycling is used.")
}
for(i in vars){
# set indicator for factors
factorflag <- FALSE
# iterate over variables to be coded
if (i %in% names(data)){
# convert factors to character
if (is.factor(data[[i]])){
data[[i]] <- as.character(data[[i]])
factorflag <- TRUE
}
# has a value been changed?
# we only want to change a given value once
changed <- rep_len(FALSE, nrow(data))
# set x to current variable
x <- data[[i]]
# iterate thru 'from' values
for(j in seq_along(from)){
f <- from[j] # current 'from' value
t <- to[j]   # corresponding 'to' value
## TODO !!!!!
# if from is NA what should changed be?
# evaluate whether values have been changed
changed <- x != data[[i]]
changed[is.na(changed)] <- FALSE
# f is NA
if (is.na(f)){
x <- ifelse(is.na(x) & !changed, t, x)
# f is an condition on x
} else if (grepl(pattern, f)) {
replacement <- paste0(df,"[['", i, "']]")
condition <- gsub(pattern, replacement, f)
x <- ifelse(eval(parse(text = condition)) & !changed,
t, x)
# otherwise
} else {
x <- ifelse(x == f & !changed, t, x)
}
}
# output new variable vector
data[[i]] <- x
# if x was factor, convert back to factor
if (factorflag){
data[[i]] <- factor(data[[i]])
}
# if 'to' value is numeric, convert x to numeric
if (is.numeric(to)){
data[[i]] <- as.numeric(data[[i]])
}
}
}
return(data)
}
df <- Recoder(mtcars, "mpg", c("$ < 15 | $ > 30"), NA)
View(df)
df <- Recoder(df, "mpg", NA, 0)
View(df)
df <- Recoder(mtcars, "am", c(0, 1), c("automatic", "manual"))
View(df)
df <- Recoder(mtcars, "carb", c("$ < 4", "$ >=4"),
c("3 or less", "4 or more"))
View(df)
df <- Recoder(mtcars, "carb", c(8), NA)
df <- Recoder(mtcars, "carb", c(2, 4), NA)
Recoder <- function(data, vars, from, to){
df <- as.character(substitute(data))
# special character representing the variable being coded when
# the 'from' vector contains conditions rather than values
pattern <- "\\$"
# recycle 'from' to match 'to' in length
if (length(from) > length(to)){
to <- rep_len(to, length(from))
message("Note: 'from' is longer than 'to', so 'to' was recycled.")
}
for(i in vars){
# set indicator for factors
factorflag <- FALSE
# iterate over variables to be coded
if (i %in% names(data)){
# convert factors to character
if (is.factor(data[[i]])){
data[[i]] <- as.character(data[[i]])
factorflag <- TRUE
}
# has a value been changed?
# we only want to change a given value once
changed <- rep_len(FALSE, nrow(data))
# set x to current variable
x <- data[[i]]
# iterate thru 'from' values
for(j in seq_along(from)){
f <- from[j] # current 'from' value
t <- to[j]   # corresponding 'to' value
## TODO !!!!!
# if from is NA what should changed be?
# evaluate whether values have been changed
changed <- x != data[[i]]
changed[is.na(changed)] <- FALSE  # test this line!
# f is NA
if (is.na(f)){
x <- ifelse(is.na(x) & !changed, t, x)
# f is an condition on x
} else if (grepl(pattern, f)) {
replacement <- paste0(df,"[['", i, "']]")
condition <- gsub(pattern, replacement, f)
x <- ifelse(eval(parse(text = condition)) & !changed,
t, x)
# otherwise
} else {
x <- ifelse(x == f & !changed, t, x)
}
}
# output new variable vector
data[[i]] <- x
# if x was factor, convert back to factor
if (factorflag){
data[[i]] <- factor(data[[i]])
}
# if 'to' value is numeric, convert x to numeric
if (is.numeric(to)){
data[[i]] <- as.numeric(data[[i]])
}
}
}
return(data)
}
df <- Recoder(mtcars, "carb", c(2, 4), NA)
View(mtcars)
df <- Recoder(mtcars, "carb", c(NA, 6), c(6, 999)
)
df <- Recoder(mtcars, "carb", c(2, 4), NA)
df <- Recoder(mtcars, "carb", c(NA, 6), c(6, 999))
str(df)
df <- Recoder(mtcars, "carb", c(2, 4), NA)
df <- Recoder(mtcars, "carb", c(NA), c(6))
debug(Recoder)
undebug(Recorder)
df <- Recoder(mtcars, "carb", c(2, 4), NA)
undebug(Recorder)
undebug(Recoder)
df <- Recoder(mtcars, "carb", c(2, 4), NA)
df <- Recoder(df, "carb", c(NA, 6), c(6, 999))
recode <- function(data, vars, from, to){
df <- as.character(substitute(data))
pattern <- "\\$"
# recycle 'from' to match 'to' in length
if (length(from) > length(to)){
to <- rep_len(to, length(from))
message("Note: 'from' is longer than 'to'. Recycling is used.")
}
for(i in vars){
factorflag <- FALSE
if (i %in% names(data)){
if (is.factor(data[[i]])){
data[[i]] <- as.character(data[[i]])
factorflag <- TRUE
}
for(j in seq_along(from)){
if (is.na(from[j])){
data[[i]] <- ifelse(is.na(data[[i]]),
to[j], data[[i]])
} else if (grepl(pattern, from[j])) {
replacement <- paste0(df,"[['", i, "']]")
condition <- gsub(pattern, replacement, from[j])
data[[i]] <- ifelse(eval(parse(text = condition)),
to[j], data[[i]])
} else {
data[[i]] <- ifelse(data[[i]] == from[j],
to[j], data[[i]])
}
}
if (factorflag){
data[[i]] <- factor(data[[i]])
}
if (is.numeric(to)){
data[[i]] <- as.numeric(data[[i]])
}
}
}
return(data)
}
df <- recode(mtcars, "cyl", 4, 2)
df <- recode(mtcars, "cyl", c(4, 6), c(40, 60))
df <- Recoder(mtcars, "carb", c(2, 4), NA)
df <- recode(mtcars, "cyl", c(4, 6), c(40, NA))
df <- recode(df, "cyl", c(NA, 40), c(999, 4))
df <- recode(mtcars, "cyl", c(4, 6), c(6, 8))
FALSE & FALSE
FALSE & TRUE
FALSE | TRUE
Recoder <- function(data, vars, from, to){
df <- as.character(substitute(data))
# special character representing the variable being coded when
# the 'from' vector contains conditions rather than values
pattern <- "\\$"
# recycle 'from' to match 'to' in length
if (length(from) > length(to)){
to <- rep_len(to, length(from))
message("Note: 'from' is longer than 'to', so 'to' was recycled.")
}
for(i in vars){
# set indicator for factors
factorflag <- FALSE
# iterate over variables to be coded
if (i %in% names(data)){
# convert factors to character
if (is.factor(data[[i]])){
data[[i]] <- as.character(data[[i]])
factorflag <- TRUE
}
# has a value been changed?
# we only want to change a given value once
changed <- rep_len(FALSE, nrow(data))
# set x to current variable
x <- data[[i]]
# iterate thru 'from' values
for(j in seq_along(from)){
f <- from[j] # current 'from' value
t <- to[j]   # corresponding 'to' value
## TODO !!!!!
# if from is NA what should changed be?
# this is not working
# evaluate whether values have been changed
changedValue <- x != data[[i]]
changedNA <- is.na(x) != is.na(data[[i]])
changed <- changedValue | changedNA
# f is NA
if (is.na(f)){
x <- ifelse(is.na(x) & !changed, t, x)
# f is an condition on x
} else if (grepl(pattern, f)) {
replacement <- paste0(df,"[['", i, "']]")
condition <- gsub(pattern, replacement, f)
x <- ifelse(eval(parse(text = condition)) & !changed,
t, x)
# otherwise
} else {
x <- ifelse(x == f & !changed, t, x)
}
}
# output new variable vector
data[[i]] <- x
# if x was factor, convert back to factor
if (factorflag){
data[[i]] <- factor(data[[i]])
}
# if 'to' value is numeric, convert x to numeric
if (is.numeric(to)){
data[[i]] <- as.numeric(data[[i]])
}
}
}
return(data)
}
df <- Recoder(mtcars, "carb", c(2, 4), NA)
df <- Recoder(df, "carb", c(NA, 6), c(6, 999))
debug(Recoder)
undebug(Recoder)
df <- Recoder(mtcars, "carb", c(2, 4), NA)
debug(Recoder)
df <- Recoder(df, "carb", c(NA, 6), c(6, 999))
df$carb
data$carb
x
data[[i]]
changedValue
changedNA
changed
Recoder <- function(data, vars, from, to){
df <- as.character(substitute(data))
# special character representing the variable being coded when
# the 'from' vector contains conditions rather than values
pattern <- "\\$"
# recycle 'from' to match 'to' in length
if (length(from) > length(to)){
to <- rep_len(to, length(from))
message("Note: 'from' is longer than 'to', so 'to' was recycled.")
}
for(i in vars){
# set indicator for factors
factorflag <- FALSE
# iterate over variables to be coded
if (i %in% names(data)){
# convert factors to character
if (is.factor(data[[i]])){
data[[i]] <- as.character(data[[i]])
factorflag <- TRUE
}
# has a value been changed?
# we only want to change a given value once
changed <- rep_len(FALSE, nrow(data))
# set x to current variable
x <- data[[i]]
# iterate thru 'from' values
for(j in seq_along(from)){
f <- from[j] # current 'from' value
t <- to[j]   # corresponding 'to' value
## TODO !!!!!
# if from is NA what should changed be?
# this is not working
# evaluate whether values have been changed
changed   <- x != data[[i]]
# deal with possible missing values in x or data[[i]]
changedNA <- is.na(x) != is.na(data[[i]])
for (k in seq_along(changed)){
if(is.na(changed[k])){
changed[k] <- changedNA[k]
}
}
# f is NA
if (is.na(f)){
x <- ifelse(is.na(x) & !changed, t, x)
# f is an condition on x
} else if (grepl(pattern, f)) {
replacement <- paste0(df,"[['", i, "']]")
condition <- gsub(pattern, replacement, f)
x <- ifelse(eval(parse(text = condition)) & !changed,
t, x)
# otherwise
} else {
x <- ifelse(x == f & !changed, t, x)
}
}
# output new variable vector
data[[i]] <- x
# if x was factor, convert back to factor
if (factorflag){
data[[i]] <- factor(data[[i]])
}
# if 'to' value is numeric, convert x to numeric
if (is.numeric(to)){
data[[i]] <- as.numeric(data[[i]])
}
}
}
return(data)
}
df <- Recoder(mtcars, "carb", c(2, 4), NA)
df <- Recoder(df, "carb", c(NA, 6), c(6, 999))
df <- Recoder(mtcars, "cyl", c(4, 6), c(40, NA))
df <- Recoder(df, "cyl", c(NA, 40), c(999, 4))
df <- Recoder(mtcars, "cyl", c(4, 6), c(6, 8))
univariatePlot <- function(data, x, bins=30,
fill="steelblue",
pointcolor="black",
density=TRUE,
densitycolor="grey",
alpha=0.2){
x <- as.character(substitute(x))
require(ggplot2)
require(patchwork)
r <- range(data[[x]], na.rm=TRUE)
minx <- floor(r[1] - (r[2] - r[1])/bins)
maxx <- ceiling(r[2] + (r[2] - r[1])/bins)
mean <- mean(data[[x]], na.rm=TRUE)
sd <- sd(data[[x]], na.rm=TRUE)
median <- median(data[[x]], na.rm=TRUE)
IQR <- IQR(data[[x]], na.rm=TRUE)
# skewness
v <- na.omit(data[[x]])
n <- length(v)
v <- v - mean(v)
v <- sqrt(n) * sum(v^3)/(sum(v^2)^(3/2))
skew <- v * ((1 - 1/n))^(3/2)
title <- paste("Univariate plots for", x)
subtitle <- paste("n=", n,
" mean =", round(mean, 2),
" sd =", round(sd, 2),
" median =", round(median, 2),
" min =", round(r[1], 2),
" max =", round(r[2], 2),
" skew =", round(skew, 2))
p1 <- ggplot(data, aes(x=.data[[x]]) ) +
geom_histogram(aes(y = ..density..),
bins=bins,
fill=fill,
color="black",
na.rm=TRUE) +
geom_vline(xintercept=mean,
linetype="dashed",
color="grey") +
scale_x_continuous(limits=c(minx, maxx)) +
labs(title=title,
subtitle=subtitle) +
theme_minimal() +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
plot.subtitle = element_text(size=8,
face="plain"))
if (density){
p1 <- p1 + geom_density(alpha=alpha, fill=densitycolor)
}
df <- data.frame(x=mean, y=0)
set.seed(1)
p2 <- ggplot(data, (aes(x=.data[[x]]))) +
geom_boxplot(fill=fill) +
geom_point(data=df,
mapping=aes(x=x, y=y),
shape="plus",
color="white",
size=1) +
scale_x_continuous(limits=c(minx, maxx)) +
theme_minimal() +
theme(axis.title.y=element_blank(),
axis.text.y=element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
df <- data.frame(x=data[[x]], y=0)
p3 <- ggplot(df, (aes(x=x, y=y))) +
geom_jitter(alpha=alpha, color=pointcolor) +
scale_x_continuous(limits=c(minx, maxx)) +
theme_minimal() +
theme(axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.title.x=element_blank(),
axis.text.x=element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
p1 + p3 + p2 + plot_layout(nrow=3, heights=c(10,2, 1))
}
?hist
?geom_histogram
library(ggplot2)
?geom_histogram
library(qacr)
?univariatePlot
?patchwork
library(qacr)
?univariatePlot
example(univariatePlot)
univariatePlot(mtcars, hp)
univariatePlot(mtcars, wt)
univariatePlot(mtcars, wt, bins=20)
library(qacr)
library(qacr)
library(pkgdown)
build_site()
build_site()
build_site()
library(qacr)
build_site()
dfPlot <- function(data){
if (!is.data.frame(data))
stop('data must be a data.frame', call.=FALSE)
require(ggplot2)
classes <- vector(mode="character",
length=length(data))
for (i in seq_along(data)){
classes[i] <- class(data[[i]])[1]
}
pct_n <-  100 *sapply(data, function(x){sum(!is.na(x))/length(x)})
df <- data.frame(var = names(data),
classes = classes,
pct_n = pct_n,
classes_n = as.numeric(as.factor(classes)))
ggplot(df,
aes(x=reorder(var, classes_n), y=pct_n, fill=classes)) +
geom_bar(stat="identity") +
labs(x="", y="Percent Available",
title=paste(as.character(deparse(substitute(data)))),
caption=paste(nrow(data), "cases",
ncol(data), "variables"),
fill="Type") +
guides(fill = guide_legend(reverse=TRUE)) +
scale_y_continuous(breaks=seq(0, 100, 20)) +
coord_flip() +
theme_minimal()
}
library(qacr)
?dfPlot
library(qacr)
?dfPlot
library(qacr)
?dfPlot
library(pkgdown)
build_site()
library(qacr)
build_site()
corPlot(coffee)
corplot(coffee)
corplot(pbp2018)
?corplot
corplot(pbp2018, lab_size = 2)
corplot(pbp2018, lab_size = 2, sort=TRUE)
corplot(coffee, lab_size=2, sort=TRUE)
library(qacr)
build_site()
